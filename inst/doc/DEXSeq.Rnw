%\VignetteIndexEntry{Analyzing RNA-seq data for differential exon usage with the "DEXSeq" package}
%\VignettePackage{DEXSeq}

% To compile this document
% library('weaver'); rm(list=ls()); unlink("DEXSeqReport", recursive=TRUE); Sweave('DEXSeq.Rnw', driver=weaver()); system('pdflatex DEXSeq')

\documentclass{article}

\usepackage{Sweave}
\usepackage[a4paper]{geometry}
\usepackage{hyperref,graphicx}
\usepackage{cite}
\usepackage{color}
\usepackage{xstring}

\SweaveOpts{keep.source=FALSE,eps=FALSE,include=FALSE,width=4,height=4.5} 
\newcommand{\Robject}[1]{\texttt{#1}}
\newcommand{\Rpackage}[1]{\textit{#1}}
\newcommand{\Rclass}[1]{\textit{#1}}
\newcommand{\Rfunction}[1]{{\small\texttt{#1}}}
\newcommand{\fixme}[1]{{\textbf{Fixme:} \textit{\textcolor{blue}{#1}}}}

\renewcommand{\floatpagefraction}{0.7}	

\title{\textsf{\textbf{Analyzing RNA-seq data for differential exon usage with the \Rpackage{DEXSeq} package}}}
\author{Alejandro Reyes, Simon Anders, Wolfgang Huber}

% The following command makes use of SVN's 'Date' keyword substitution
% To activate this, I used: svn propset svn:keywords "Date" DEXSeq.Rnw
\date{\StrMid{$Date$}{8}{18}}

\begin{document}
\maketitle
\tableofcontents

\begin{abstract}
  RNA-seq is a powerful tool for transcriptome analysis. It enables
  the discovery of novel transcript splice sites and isoforms, and
  there is interest in the quantitative comparison of exon usage
  between different conditions.  For the analysis of differential
  expression between conditions, appropriate modeling of the
  experimental and biological variability is important, and such
  capabilities are offered, for instance, by the packages
  \Rpackage{edgeR}~\cite{edgeR} and
  \Rpackage{DESeq}~\cite{Anders:2010:GB}. However, there is currently no
  software that specifically addresses exon level expression and
  differential exon usage.  In this package, we provide a method to
  systematically detect differential exon usage using RNA-seq.  We use
  as input the number of reads mapping to each of the exons of a
  genome. The method is demonstrated on the data from the package
  \Rpackage{pasilla}. 
\end{abstract}

%-----------------------------------------------------------
\section{The Pasilla dataset}
%-----------------------------------------------------------
We will use the \Robject{pasillaExons} dataset from the \Rpackage{pasilla} package. 
\Robject{pasillaExons} is an object of class \Rclass{ExonCountSet}.
Brooks et al.~\cite{Brooks2010} investigated the effect of siRNA knock-down of Pasilla, whose protein
is known to bind to mRNA in the spliceosome, and which is thought to be involved 
in the regulation of splicing, on the transcriptome of fly S2-DRSC cells.  
Pasilla is the Drosophila melanogaster ortholog of mammalian NOVA1 and NOVA2.
The dataset, which is provided by NCBI Gene Expression Omnibus (GEO) under the accession number
GSE18508\footnote{\url{http://www.ncbi.nlm.nih.gov/projects/geo/query/acc.cgi?acc=GSE18508}}, 
contains 3 biological replicates of the knockdown as well as 4 biological replicates for the untreated control. 

In the \Rpackage{pasilla} package, we provide data from a subset of
genes.  A subset was chosen in order to speed up the computations
shown in this vignette. We start by loading the \Rpackage{DEXSeq}
package and the example data.

<<options,results=hide,echo=FALSE>>=
options(digits=3)
@  
<<start,results=hide>>=
library("DEXSeq")
<<datapasilla>>=
data("pasillaExons", package="pasilla")
@ 

If you have not yet installed the \Rpackage{pasilla} package, you can do so with
<<install_pasilla,eval=FALSE>>
source("http://www.bioconductor.org/biocLite.R")
biocLite("pasilla")
@

The \Rfunction{pData} accessor function shows the available sample annotations.
<<pData>>=
pData(pasillaExons)
@ 
We also print the first \Sexpr{formals(utils:::head.data.frame)$n} lines of selected
columns of the feature data annotation:
<<fData>>=
head(fData(pasillaExons)[,c(1,2,7:10)])
@   
<<tabtab1,echo=FALSE>>=
tg = table(geneIDs(pasillaExons)) 
tt = table(tg)
stopifnot(tt["36"]==1, tt["16"]==3)
@ 
There are \Sexpr{sum(tg>0)} genes in the dataset, of these, there is one with 36 exons, and for instance,
three with 16 exons:
<<tabtab2>>=
table(table(geneIDs(pasillaExons))) 
@ 
In Section~\ref{sec:creating}, we explain how you can create analogous data objects from your own data.

%--------------------------------------------------
\section{Normalisation and dispersion estimation}\label{sec:norm}
%--------------------------------------------------
Different samples might be sequenced with different depths. In order to adjust for such coverage biases, 
we introduce size factor parameters.  \Rpackage{DEXSeq} uses the same method
as \Rpackage{DESeq}, which is provided in the function \Rfunction{estimateSizeFactors}. 
<<sizeFactors1,cache=TRUE>>=
pasillaExons <- estimateSizeFactors(pasillaExons)
<<sizeFactors2>>=
sizeFactors(pasillaExons)
@

To test for differential expression, we need to estimate the data's variance. This is needed
to be able to distinguish between normal technical and biological variation (noise) and real effects
on gene expression between the different conditions.  
The information on the size of the noise is drawn from the biological replicates in the dataset.
However, as typical for RNA-seq experiments, the number of replicates is too small to estimate
variance or dispersion parameters individually gene by gene. Instead, variance information is shared
across genes, in an intensity dependent manner. Computationally, this is done through Cox-Reid 
likelihood estimation (our method follows that of the package \Rpackage{edgeR}~\cite{edgeR}), and 
by fitting a regression of the dispersion values on the mean. These steps are implemented in the 
function \Rfunction{estimateDispersions}.
%
<<estDisp1,cache=TRUE,results=hide>>=
pasillaExons <- estimateDispersions(pasillaExons)
@

The result from the Cox-Reid estimation is stored in the column \Robject{dispersion\_CR\_est}
of the feature data. Then, the dispersion-mean relation $\alpha = \alpha_0 + \alpha_1/\mu$ is
fit to these values (and the coefficients stored in slot \Robject{dispFitCoefs}).
Finally, for each exon, the maximum of the CR estiomate and the fitted value
is taken as the exon's final dispersion value and stored in the \Robject{dispersion} slot.

<<estDisp2>>=
head(fData(pasillaExons)$dispersion_CR_est)
pasillaExons@dispFitCoefs
head(fData(pasillaExons)$dispersion)
@
%

In Section~\ref{sec:glm}, we will see how to incorporate further experimental or technical variables
into the dispersion estimation.

%\fixme{Why are the two dispersion estimates so different, and why do we need to show them both? 
%See Figure~\ref{figCR} and below.}

%\fixme{Insert a sentence to give some intuition on how ``large'' or ``small'' these dispersion values are.}

%<<figCR,fig=TRUE>>=
%plot(fData(pasillaExons)[,c("dispersion","dispersion_CR_est")], xlim=c(0,50))
%abline(a=0,b=1,col="orange")
%@ 
%<<weird>>=
%weird = function(x) table( (x>50) | (!is.finite(x)))
%weird(fData(pasillaExons)$dispersion)
%weird(fData(pasillaExons)$dispersion_CR_est)
%@ 
%\begin{figure}
%\centering
%\includegraphics[width=0.5\textwidth]{DEXSeq-figCR}
%\caption{Comparison of two different dispersion estimates.}
%\label{figCR}
%\end{figure}
%     

%--------------------------------------------------
\section{Testing for differential exon usage}\label{sec:deu}
%--------------------------------------------------
Having the dispersion estimates and the size factors, we can now test for differential exon usage. 
For each gene, we fit a generalized linear model with the formula
\[
\mbox{\texttt{sample + exon + condition * I(exon == exonID)}}
\]
and compare it to the smaller model (the null model) 
\[
\mbox{\texttt{sample + exon + condition}.}
\]
We compare the deviances of both fits using a $\chi^2$-distribution. 
To create a data frame that encodes the model for a gene, with
columns \texttt{sample}, \texttt{exon}, \texttt{condition}, \texttt{sizeFactors} and 
\texttt{count}, the function \Rfunction{modelFrameForGene} is used.
<<mffg1>>=
head( modelFrameForGene( pasillaExons, "FBgn0010909" ) )
@ 
The actual test (which already includes a call to \Rfunction{modelFrameForGene}) is
performed by the function \Rfunction{testGeneForDEU}:  
<<mffg2>>=
testGeneForDEU( pasillaExons, "FBgn0010909" )
@
<<mffg3,echo=FALSE,results=hide>>=
tgdeu = testGeneForDEU( pasillaExons, "FBgn0010909" )
specialExon = "E010"
stopifnot(tgdeu[specialExon,"pvalue"]<1e-7)
@ 
We see that there is one exon, \texttt{\Sexpr{specialExon}}, with a very small $p$ value, while for all other exons,
the $p$ values are unremarkable.

A convenient interface which calls \Rfunction{testGeneForDEU} for all genes
and fills the \Robject{pvalue} and \Robject{padjust} columns of the \Robject{featureData} slots 
of the \Rclass{ExonCountSet} object with the results is provided by the
function \Rfunction{testForDEU}.  
<<testForDEU1,cache=TRUE>>=
pasillaExons <- testForDEU( pasillaExons )
@ 
The function \Rfunction{DEUresultTable} provides a summary table of the results.
<<testForDEU2,cache=TRUE>>=
res1 <- DEUresultTable(pasillaExons)
<<testForDEU3>>=
table ( res1$padjust < 0.1 )
@
%$
%------------------------------------------------------------
\section{Batch effects}\label{sec:glm}
%------------------------------------------------------------
In the previous section we performed the analysis of differential exon usage ignoring the information regarding
the library type of the samples.  
<<design>>=
design(pasillaExons)
@
In this section, we show how to take the factor \Robject{type} into account in the analysis.
First, we need to provide the function \Rfunction{estimateDispersions} with a formula that makes
it aware of the additional factor (besides \Robject{condition}, which it considers by default).
%
<<formuladispersion,cache=TRUE>>=
formuladispersion <- count ~ sample + ( exon + type ) * condition
pasillaExons <- estimateDispersions( pasillaExons, formula = formuladispersion )
@
%
Second, for the testing, we will also change the two formulas to take into account the library type. 
%
<<formula1>>=
formula0 <- count ~ sample + type * exon + condition
formula1 <- count ~ sample + type * exon + condition * I(exon == exonID)
<<formula2,cache=TRUE>>=
pasillaExons <- testForDEU( pasillaExons, formula0=formula0, formula1=formula1 )
res2 <- DEUresultTable( pasillaExons )
<<formula3>>=
table( res2$padjust < 0.1 )
@
%$

\fixme{The results look not very different from those of Section~\ref{sec:deu}:}
<<figcomparep,fig=TRUE>>=
bottom = function(x) pmax(x, 1e-6)
plot(bottom(res1$padjust), bottom(res2$padjust), log="xy")
@ 
See Figure~\ref{figcomparep}.
\begin{figure}
\centering
\includegraphics[width=.5\textwidth]{DEXSeq-figcomparep}
\caption{Comparison of differential exon usage 
$p$ values from analysis with ($y$-axis, \Robject{res2}) and without ($x$-axis, \Robject{res1}) 
consideration of batch (library type) effects.}
\label{figcomparep}
\end{figure}

%--------------------------------------------------
\section{Visualization}
%--------------------------------------------------
\Rpackage{DEXSeq} has a function to visualize the results of \Rfunction{testForDEU}. 
%
<<plot1, fig=TRUE, height=8, width=12>>=
plotDEXSeq(pasillaExons, "FBgn0010909", cex.axis=1.2, cex=1.3, lwd=2, legend=TRUE)
@
\begin{figure}
\centering
\includegraphics[width=\textwidth]{DEXSeq-plot1}
\caption{The plot represents the expression estimates from a call to \texttt{testForDEU}.
Shown in red is the exon that showed significant differential exon usage.}
\label{figplot1}
\end{figure}

<<checkClaim,echo=FALSE>>=
wh = (fData(pasillaExons)$geneID=="FBgn0010909")
stopifnot(sum(fData(pasillaExons)$padjust[wh] < formals(plotDEXSeq)$FDR)==1)
@ 

The result is shown in Figure~\ref{figplot1}.
Optionally, one can also visualize the transcript models (Figure~\ref{figplot2}), which might be
useful for putting differential exon usage results into the context of isoform regulation.
%
<<plot2, fig=TRUE, height=8, width=12>>=
plotDEXSeq(pasillaExons, "FBgn0010909", displayTranscripts=TRUE, cex.axis=1.2, cex=1.3, lwd=2, legend=TRUE)
@
\begin{figure}
\centering
\includegraphics[width=\textwidth]{DEXSeq-plot2}
\caption{As in Figure~\ref{figplot1}, but including the annotated transcript models.}
\label{figplot2}
\end{figure}

Another useful option is to look at the count values from the individual samples, rather than at the
model effect estimates. For this display, it is useful to normalize the counts by the size factors (Figure~\ref{figplot3}).
%
<<plot3, fig=TRUE, height=8, width=12>>=
plotDEXSeq(pasillaExons, "FBgn0010909", coefficients=FALSE, norCounts=TRUE, cex.axis=1.2, cex=1.3, lwd=2, legend=TRUE)
@
\begin{figure}
\centering
\includegraphics[width=\textwidth]{DEXSeq-plot3}
\caption{As in Figure~\ref{figplot1}, with normalized count values of each exon in each of the samples.}
\label{figplot3}
\end{figure}

To generate an easily browsable, detailed overview over all analysis results, 
the package provides an HTML report generator, implemented in the function \Rpackage{DEXSeqHTML}.  
This function uses the package \Rpackage{hwriter} to create a result table with links to plots for the 
significant results, allowing a more detailed exploration of the results. To see an example, visit 
\url{http://www.embl.de/~reyes/DEXSeqReport/testForDEU.html}. The report shown there was generated using this code.
%
<<DEXSeqHTML,cache=TRUE, eval=FALSE>>=
DEXSeqHTML( pasillaExons, FDR=0.1, color=c("#FF000080", "#0000FF80") )
@
%--------------------------------------------------
\section{Parallelization}
%--------------------------------------------------
DEXSeq analysis can be computationally slow with large datasets due to the number of iterations and glms
that are fitted, especially with datasets with a big number of samples, or organisms containing genes with
a large number of exons.  There are some steps of the analysis that require the whole dataset, but the two 
parts that are most time consuming can be paralellized (functions \Rfunction{estimateDispersions} and 
\Rfunction{testForDEU}).  This section of the vignette shows which parts of the analysis can be paralellized, 
using as an example the library \Rpackage{multicore}.
%
<<para1,cache=TRUE,eval=FALSE>>=
data("pasillaExons", package="pasilla")
pasillaExons <- estimateSizeFactors( pasillaExons )
@

We use the function \Rfunction{subsetByGenes} to make a list of smaller ExonCountSet objects and we use the
function \Rfunction{mcapply} from the library \Rpackage{multicore} to paralellize the process. Note that it is
important to subet it using the whole exons of the genes because of the way the glms are fitted.  (see function \Rfunction{modelFrameForGene}).
For this particular case, we will divide our \Robject{ExonCountSet} object into a list containing 5 smaller
\Robject{ExonCountSet} objects.
%
<<subset1, cache=TRUE,eval=FALSE>>=
forsubset <- rep(1:5, each=length( levels( geneIDs(pasillaExons) ) )/5)
subgenes <- split(levels(geneIDs(pasillaExons)), forsubset)
allecs <- sapply(subgenes, 
   function(x){ 
      subsetByGenes( pasillaExons, x ) 
   } )
@

The most time consuming process of DEXSeq is the Cox-Reid dispersion estimation.  This is computed by the function
\Rfunction{estimateDispersions}, this function also then makes the mean-variance fit on them by calling the function \Rfunction{fitDispersions} internally.  
Dividing the object into smaller parts allow us to parallelize the exon dispersion estimation (using just two cores in this case),
but the fitting might be recommendable using the whole dataset.  We do this by setting the parameter fitDispersions to FALSE when calling \Rfunction{estimateDispersions} and then call
\Rfunction{fitDispersions} after putting the all the parts together.
%
<<par-dispersions, cache=TRUE,eval=FALSE>>=
library(multicore)
allecs <- mclapply(allecs, 
   estimateDispersions, 
      quiet=TRUE, 
      fitDispersions=FALSE,
   mc.cores=2)
pasillaExons <- allecs[[1]]
for(i in 2:5){ 
   pasillaExons <- combine(pasillaExons, allecs[[i]])
}
pasillaExons <- fitDispersions( pasillaExons )
@
We divide again the \Robject{ExonCountSet} object to divide the testing part in several cores. From this part it is 
reccomendable to make the multiple testing correction after joining all the parts.
<<par-testing,cache=TRUE,eval=FALSE>>=
allecs <- sapply(subgenes, 
   function(x){ 
      subsetByGenes( pasillaExons, x ) 
   } )
allecs <- mclapply(allecs, 
   testForDEU, 
      padjust=FALSE,
      quiet=TRUE,
   mc.cores=2)
pasillaExons <- allecs[[1]]
for(i in 2:5){ 
   pasillaExons <- combine(pasillaExons, allecs[[i]])
}
fData( pasillaExons )$padjust <- p.adjust( fData( pasillaExons )$pvalue, method="BH")
@

%--------------------------------------------------
\section{Gene count table}
%--------------------------------------------------
The function \Rfunction{geneCountTable} computes a table of \emph{gene counts}, which are obtained by summing
the counts from all exons with the same geneID.  This might be useful for the detection of differential expression
of genes, where the table can be used as input e.\,g.\ for the packages
\Rpackage{DESeq} or \Rpackage{edgeR}.
<<gct>>=
head(geneCountTable(pasillaExons))
@ 

%--------------------------------------------------
\section{Creating \Rclass{ExonCountSet} objects}\label{sec:creating}
%--------------------------------------------------
\subsection{From files produced by \texttt{HTSeq}}

In this section, we describe how to create an \Rclass{ExonCountSet} from an alignment of the RNA-seq reads to the genome,  
in SAM format, and a file describing gene and transcript models in GTF format.

The first steps of this workflow involve two scripts for the Python library \Rpackage{HTSeq}.
These scripts are provided as part of the R package \Rpackage{DEXSeq}.
The first script, \texttt{dexseq\_prepare\_annotation.py}, parses an annotation file in GTF format to define non-overlapping 
exonic regions: for instance, consider a gene whose transcripts contain either of two exons whose genomic
regions overlap. In such a case, the script defines three exonic 
regions: two for the non-overlapping parts of each of the two exons, and a third one for the overlapping part. 
The script produces as output a new file in GTF format.  The second script, 
\texttt{dexseq\_count.py}, reads the GTF file produced by \texttt{dexseq\_prepare\_annotation.py} and an alignment 
in SAM format and counts the number of reads falling in each of the defined exonic regions. 

The \Rpackage{DEXSeq} function \Rfunction{read.HTSeqCounts} is then able to read the output from these scripts 
and returns an \Rclass{ExonCountSet} object with the relevant information for 
differential exon usage analysis and visualization. Of course,
users can postprocess or replace the annotation in the object using their own means in R. 

The files that were used in this way to create the \Robject{pasillaGenes} object
are provided within the \Rpackage{pasilla} package:
<<dirpasilla>>=
dir(system.file("extdata",package="pasilla"))
@   
The vignette\footnote{Data preprocessing and creation of the data objects pasillaGenes and pasillaExons} 
of the package \Rpackage{pasilla} provides a complete transcript of these steps.

\subsection{From elementary R data structures}

Users can also provide their own data, contained in elementary R objects, directly to the function 
\Rfunction{newExonCountSet} in order to create an \Rclass{ExonCountSet} object.
The minimum requirements are 
\begin{enumerate}
\item a per-exon count matrix, with one row for every exon and one column for every sample,
\item a vector, matrix or data frame with information about the samples, and
\item two vectors of gene and exon identifiers that align with the rows of the count matrix.
\end{enumerate}
With such a minimal object, it is possible to perform the analysis for differential exon usage, 
but the visualization functions will not be so useful. 
The necessary information about exons start and end positions can be given as a data frame to 
the \Rfunction{newExonCountSet} function, or can be added to the \Rclass{ExonCountSet} object after its creation
via the \Rfunction{featureData} accessor. For more information, please see the manual page of \Rfunction{newExonCountSet}.
%
<<ecswithout>>=
bare <- newExonCountSet(
   countData = counts(pasillaExons), 
   design=design(pasillaExons), 
   geneIDs=geneIDs(pasillaExons), 
   exonIDs=exonIDs(pasillaExons))
@
%$

\bibliography{DEXSeq}
\bibliographystyle{plain}

\section{Session Information}
<<sessionInfo>>=
sessionInfo()
@ 
\end{document}
